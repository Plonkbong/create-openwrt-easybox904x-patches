From 8f9cf91723612e0f73d6ffbb9a29362927b89c93 Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Tue, 26 Feb 2019 11:34:42 +0000
Subject: [PATCH] This commit adds support for the Arcadyan/Astoria
 VGV952CJW33-E-IR Router aka Vodafon Easybox-904xDSL It base on Quallenauge
 git from here https://github.com/Quallenauge/Easybox-904-XDSL Information:
 https://forum.openwrt.org/t/support-for-easybox-904-lte/14478
 https://openwrt.org/toh/astoria/arcadyan_astoria_easybox_904xdsl_r01
 https://www.randomprojects.org/wiki/Vodafone_EasyBox_904_xDSL

Hardware:
---------
CPU:	    Lantiq PSB 80920 EL V1.2		   VRX200 2x500MHz with a mips32 architekture called mips_34Kc
RAM:	    EtronTech EM68C16CWQD-25H		   128MB DDRII SDRAM 400MHz
Flash: 	    Samsung K9F4G08U0x			   256MiB NAND-flash
Ethernet:   Realtek RTL8367RB			   4x 10/100/1000 Mbit/s vlan support
Wlan:	    Realtek RT3883F + RT5392L		   5GHz/2.4GHz 802.11abgn
USB: 	    ?					   2 x USB-2.0
Serial:	    (from CPU)				   yes with connectors
xDSL-Modem: Lantiq PSB 80190 V V1.1 XWAY VRX208    up to VDSL2 profile 30a and Vectoring support
POTS:	    Lantiq PEF 42068 V V1.2 XWAY SLIC120   2 x FXS Analog Telefon ports
ISDN: 	    Lantiq PEF 82902 F V1.1 T TSMINTI 4B3T 1 x S0-Bus
LCD-Screen: ILITEK ILI9341			   TFT LCD 320x240 RGB 262K colors
Touchpad:   ?					   yes

It exist some restrictions:
- The VRX200 have some speedlimitations under Openwrt
- Driver for WLAN and touchpad
found here: https://github.com/Quallenauge/lede-feeds-easybox904
and here optimised for SDK build: https://github.com/Plonkbong/eb904x-feedfix
- WLAN non standart Driver because WiSoc, only AP mode are possible
- xDSL-Modem it is not know whish ADSL-annexes are supported / Vectoring are only with an self extracted image possible
- ISDN not supported yet and in future

Building:
---------
for an working WLAN it is required to enable devmem in kernel and bussybox:
CONFIG_BUSYBOX_CUSTOM=y
CONFIG_BUSYBOX_CONFIG_DEVMEM=y
CONFIG_KERNEL_DEVMEM=y

Installation:
-------------
short:
1.) use the UBoot-tftp method to install the initramfs image at your router and start it again
2.) This is optional but usefull:
override the password locked uboot with an free uboot from here:
linked in https://github.com/Quallenauge/Easybox-904-XDSL commit fa8e9a88891841f6b4a35296315db68526cde2f1 from 27.06.2018
SHA256: 4d035b3777f1a93090e7f0bd8faf2fa83f4b1bc0570de076f5f5cdbc8680ea9a
3.) install the sysupgrade-image via sysupgrade
long:
see https://github.com/Quallenauge/Easybox-904-XDSL

Serial:
-------
parameter: 115200, 8N1

------------------------------------
upper edge from Router             |
------------------------           |
                                   |
<quartz> 4 3 2 1 <capacitor>       |
                                   |
                                   |
connectors                         |
------------------------------------

Pin 1 	Vcc 3.3V (DO NOT CONNECT, since it could irreparably damage the device.)
Pin 2 	TX
Pin 3 	RX
Pin 4 	GND

Signed-off-by: Your Name <you@example.com>
---
 .../network/config/ltq-vdsl-app/files/dsl_control  |  28 +-
 .../linux/lantiq/base-files/etc/board.d/02_network |  11 +-
 target/linux/lantiq/base-files/etc/diag.sh         |  46 ++
 .../base-files/etc/uci-defaults/80_wifi_setup      |  72 ++++
 .../base-files/lib/preinit/06_init_network_lantiq  |  19 +
 .../lib/preinit/85_reset_watchdog_timer_lantiq     |  31 ++
 .../lantiq/base-files/lib/upgrade/platform.sh      |  17 +-
 .../arch/mips/boot/dts/VGV952CJW33-E-IR.dts        | 477 +++++++++++++++++++++
 target/linux/lantiq/image/Makefile                 |  52 ++-
 .../4027-NET-MIPS-lantiq-support-fixed-link.patch  |  84 ++++
 .../4028-NET-MIPS-lantiq-add-FID-setting.patch     |  86 ++++
 .../4050-MIPS-lantiq-EBU-set_buscon_params.patch   |  32 ++
 .../4052-NAND-add-easybox904-bbt-byDTS.patch       | 131 ++++++
 ...4053-NET-reactivate-ndo_do_ioctl-fallback.patch |  27 ++
 .../4055-NET-rtl8367b-wait-for-mdio-bus.patch      |  54 +++
 ...msung_disable_subpage_writes_on_21nm_NAND.patch |  55 +++
 16 files changed, 1213 insertions(+), 9 deletions(-)
 create mode 100644 target/linux/lantiq/base-files/etc/diag.sh
 create mode 100644 target/linux/lantiq/base-files/etc/uci-defaults/80_wifi_setup
 create mode 100644 target/linux/lantiq/base-files/lib/preinit/06_init_network_lantiq
 create mode 100644 target/linux/lantiq/base-files/lib/preinit/85_reset_watchdog_timer_lantiq
 create mode 100644 target/linux/lantiq/files-4.14/arch/mips/boot/dts/VGV952CJW33-E-IR.dts
 create mode 100644 target/linux/lantiq/patches-4.14/4027-NET-MIPS-lantiq-support-fixed-link.patch
 create mode 100644 target/linux/lantiq/patches-4.14/4028-NET-MIPS-lantiq-add-FID-setting.patch
 create mode 100644 target/linux/lantiq/patches-4.14/4050-MIPS-lantiq-EBU-set_buscon_params.patch
 create mode 100644 target/linux/lantiq/patches-4.14/4052-NAND-add-easybox904-bbt-byDTS.patch
 create mode 100644 target/linux/lantiq/patches-4.14/4053-NET-reactivate-ndo_do_ioctl-fallback.patch
 create mode 100644 target/linux/lantiq/patches-4.14/4055-NET-rtl8367b-wait-for-mdio-bus.patch
 create mode 100644 target/linux/lantiq/patches-4.14/4056-MTD-nand_samsung_disable_subpage_writes_on_21nm_NAND.patch

diff --git a/package/network/config/ltq-vdsl-app/files/dsl_control b/package/network/config/ltq-vdsl-app/files/dsl_control
index e62a5e5..1ee4309 100644
--- a/package/network/config/ltq-vdsl-app/files/dsl_control
+++ b/package/network/config/ltq-vdsl-app/files/dsl_control
@@ -219,7 +219,29 @@ start_service() {
 	esac
 
 	local annexgpio="/sys/class/gpio/annex"
-	if [ -d "${annexgpio}a" ] && [ -d "${annexgpio}b" ]; then
+	local dsl_en_gpio="/sys/class/gpio/dsl_en"
+	if [ -d "${dsl_en_gpio}" ]; then
+		echo 1 > "${dsl_en_gpio}/value"
+	fi
+	if  [ -d "${annexgpio}a" ] && [ -d "${annexgpio}b" ] && [ -d "${annexgpio}j" ]; then
+		case "${annex}" in
+			a*|l*|m*)
+				echo 1 > "${annexgpio}a/value"
+				echo 0 > "${annexgpio}b/value"
+				echo 0 > "${annexgpio}j/value"
+				;;
+			b*)
+				echo 0 > "${annexgpio}a/value"
+				echo 1 > "${annexgpio}b/value"
+				echo 0 > "${annexgpio}j/value"
+				;;
+			i*|j*)
+				echo 0 > "${annexgpio}a/value"
+				echo 0 > "${annexgpio}b/value"
+				echo 1 > "${annexgpio}j/value"
+				;;
+		esac
+	elif [ -d "${annexgpio}a" ] && [ -d "${annexgpio}b" ]; then
 		case "${annex}" in
 			a*|l*|m*)
 				echo 1 > "${annexgpio}a/value"
@@ -313,4 +335,8 @@ stop_service() {
 	DSL_NOTIFICATION_TYPE="DSL_INTERFACE_STATUS" \
 	DSL_INTERFACE_STATUS="DOWN" \
 		/sbin/dsl_notify.sh
+	local dsl_en_gpio="/sys/class/gpio/dsl_en"
+	if [ -d "${dsl_en_gpio}" ]; then
+		echo 0 > "${dsl_en_gpio}/value"
+	fi
 }
diff --git a/target/linux/lantiq/base-files/etc/board.d/02_network b/target/linux/lantiq/base-files/etc/board.d/02_network
index 8689440..ad0c585 100755
--- a/target/linux/lantiq/base-files/etc/board.d/02_network
+++ b/target/linux/lantiq/base-files/etc/board.d/02_network
@@ -195,7 +195,7 @@ arcadyan,vg3503j)
 		"2:lan:2" "4:lan:1" "6t@eth0"
 	;;
 
-tplink,vr200|tplink,vr200v)
+tplink,vr200v)
 	wan_mac=$(macaddr_add "$(mtd_get_mac_binary romfile 61696)" 1)
 	ucidef_add_switch "switch0" \
 		"0:lan" "2:lan" "4:lan" "5:lan" "6t@eth0"
@@ -208,6 +208,15 @@ arcadyan,vgv7510kw22-nor|arcadyan,vgv7510kw22-brn)
 		"2:lan:2" "3:lan:1" "4:lan:4" "5:lan:3" "0:wan:5" "6t@eth0"
 	;;
 
+lantiq,vgv952cjw33-e-ir*)
+	lan_mac=$(mtd_get_mac_ascii ubootconfig ethaddr)
+	wan_mac=$(macaddr_add "$lan_mac" 1)
+	ucidef_add_switch "switch0" \
+	"0:lan" "4:wan" "6@eth0"
+	ucidef_add_switch "switch1" \
+	"0:lan" "1:lan" "2:lan" "3:lan" "6@eth0"
+	;;
+
 arcadyan,vgv7519-nor|arcadyan,vgv7519-brn)
 	wan_mac=$(mtd_get_mac_binary board_config 22)
 	ucidef_add_switch "switch0" \
diff --git a/target/linux/lantiq/base-files/etc/diag.sh b/target/linux/lantiq/base-files/etc/diag.sh
new file mode 100644
index 0000000..06cf7e2
--- /dev/null
+++ b/target/linux/lantiq/base-files/etc/diag.sh
@@ -0,0 +1,46 @@
+#!/bin/sh
+# Copyright (C) 2010-2015 OpenWrt.org
+
+. /lib/functions/leds.sh
+
+boot="$(get_dt_led boot)"
+failsafe="$(get_dt_led failsafe)"
+running="$(get_dt_led running)"
+upgrade="$(get_dt_led upgrade)"
+
+set_state() {
+	status_led="$boot"
+
+	case "$1" in
+	preinit)
+		status_led_blink_preinit
+		;;
+	failsafe)
+		status_led_off
+		[ -n "$running" ] && {
+			status_led="$running"
+			status_led_off
+		}
+		status_led="$failsafe"
+		status_led_blink_failsafe
+		;;
+	preinit_regular)
+		status_led_blink_preinit_regular
+		;;
+	upgrade)
+		[ -n "$running" ] && {
+			status_led="$running"
+			status_led_off
+		}
+		status_led="$upgrade"
+		status_led_blink_preinit_regular
+		;;
+	done)
+		status_led_off
+		[ -n "$running" ] && {
+			status_led="$running"
+			status_led_on
+		}
+		;;
+	esac
+}
diff --git a/target/linux/lantiq/base-files/etc/uci-defaults/80_wifi_setup b/target/linux/lantiq/base-files/etc/uci-defaults/80_wifi_setup
new file mode 100644
index 0000000..503ace8
--- /dev/null
+++ b/target/linux/lantiq/base-files/etc/uci-defaults/80_wifi_setup
@@ -0,0 +1,72 @@
+#!/bin/sh
+
+. /lib/functions/uci-defaults.sh
+. /lib/functions/system.sh
+. /lib/functions/lantiq.sh
+
+board=$(board_name)
+
+case "$board" in
+lantiq,vgv952cjw33-e-ir*)
+        wlan_dev=$(uci get network.wlan_dev.name)
+        if [ "$wlan_dev" = "eth0.66" ]; then
+           echo "wlan seems to intially setup - don't touch config"
+           return
+        fi
+
+	# Add interface for communicating with the iNIC
+	uci -q batch <<-EOF
+		set network.inic_dev='device'
+		set network.inic_dev.name='eth0.3'
+
+		set network.inic='interface'
+		set network.inic.proto='none'
+		set network.inic.ifname='eth0.3'
+	EOF
+
+	# Add VLAN with untagged port for communicating with the iNIC
+	uci -q batch <<-EOF
+		add network switch_vlan
+		set network.@switch_vlan[-1].device='switch0'
+		set network.@switch_vlan[-1].vlan='3'
+		set network.@switch_vlan[-1].vid='3'
+		set network.@switch_vlan[-1].fid='3'
+		set network.@switch_vlan[-1].ports='5 6t'
+	EOF
+
+	# Add interface for normal wlan traffic
+	uci -q batch <<-EOF
+		set network.wlan_dev='device'
+		set network.wlan_dev.name='eth0.66'
+		add_list network.lan.ifname='eth0.66'
+	EOF
+
+	# Add interface for guest wlan traffic
+	uci -q batch <<-EOF
+		set network.guest_wlan_dev='device'
+		set network.guest_wlan_dev.name='eth0.71'
+	EOF
+
+	# Add VLAN with tagged port for communicating with the iNIC wlan
+	uci -q batch <<-EOF
+		add network switch_vlan
+		set network.@switch_vlan[-1].device='switch0'
+		set network.@switch_vlan[-1].vlan='4'
+		set network.@switch_vlan[-1].vid='66'
+		set network.@switch_vlan[-1].fid='4'
+		set network.@switch_vlan[-1].ports='5t 6t'
+	EOF
+
+	# Add VLAN with tagged port for communicating with the iNIC guest wlan
+	uci -q batch <<-EOF
+		add network switch_vlan
+		set network.@switch_vlan[-1].device='switch0'
+		set network.@switch_vlan[-1].vlan='5'
+		set network.@switch_vlan[-1].vid='71'
+		set network.@switch_vlan[-1].fid='5'
+		set network.@switch_vlan[-1].ports='5t 6t'
+	EOF
+	;;
+esac
+
+exit 0
diff --git a/target/linux/lantiq/base-files/lib/preinit/06_init_network_lantiq b/target/linux/lantiq/base-files/lib/preinit/06_init_network_lantiq
new file mode 100644
index 0000000..8a1c9fe
--- /dev/null
+++ b/target/linux/lantiq/base-files/lib/preinit/06_init_network_lantiq
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+. /lib/functions/lantiq.sh
+
+set_preinit_misc_lantiq() {
+board=$(board_name)
+
+case "$board" in
+lantiq,vgv952cjw33-e-ir*)
+        # Enable VLAN on lantiq switch
+        swconfig dev switch0 vlan 1 set ports "0 1 2 3 4 5 6"
+
+        #Enable VLAN on rtl8637b switch
+        swconfig dev switch1 vlan 1 set ports "0 1 2 3 4 5 6"
+        ;;
+esac
+}
+
+boot_hook_add preinit_main set_preinit_misc_lantiq
diff --git a/target/linux/lantiq/base-files/lib/preinit/85_reset_watchdog_timer_lantiq b/target/linux/lantiq/base-files/lib/preinit/85_reset_watchdog_timer_lantiq
new file mode 100644
index 0000000..64a3246
--- /dev/null
+++ b/target/linux/lantiq/base-files/lib/preinit/85_reset_watchdog_timer_lantiq
@@ -0,0 +1,31 @@
+#!/bin/sh
+
+. /lib/functions/lantiq.sh
+
+reset_watchdog_timer_lantiq() {
+board=$(board_name)
+
+case "$board" in
+lantiq,vgv952cjw33-e-ir*)
+        # Add envtools configuration
+        if [ -e /etc/uci-defaults/30_uboot-envtools ]; then
+                echo "fw_config is generated now"
+                /bin/sh /etc/uci-defaults/30_uboot-envtools
+        else
+                echo "fw_config exists already"
+        fi
+
+        BOOTNUM=`/usr/sbin/fw_printenv bootnum -n`
+        echo "Bootnum: $BOOTNUM"
+        if [[ ! -z "$BOOTNUM" ]]; then
+                if [[ "$BOOTNUM" -ge 4 ]]; then
+                        # Reset bootnum to not interfere with the recovery trigger of uboot.
+                        # Only jumps in on vendor uboot.
+                        /usr/sbin/fw_setenv bootnum
+                fi
+        fi
+        ;;
+esac
+}
+
+boot_hook_add preinit_main reset_watchdog_timer_lantiq
diff --git a/target/linux/lantiq/base-files/lib/upgrade/platform.sh b/target/linux/lantiq/base-files/lib/upgrade/platform.sh
index ecbb939..c62761d 100755
--- a/target/linux/lantiq/base-files/lib/upgrade/platform.sh
+++ b/target/linux/lantiq/base-files/lib/upgrade/platform.sh
@@ -15,7 +15,8 @@ platform_do_upgrade() {
 	bt,homehub-v3a|\
 	bt,homehub-v5a|\
 	zyxel,p-2812hnu-f1|\
-	zyxel,p-2812hnu-f3)
+	zyxel,p-2812hnu-f3|\
+	lantiq,vgv952cjw33-e-ir)
 		nand_do_upgrade $1
 		;;
 	*)
@@ -23,3 +24,17 @@ platform_do_upgrade() {
 		;;
 	esac
 }
+
+platform_nand_pre_upgrade() {
+	local board=$(board_name)
+	echo "platform_nand_pre_upgrade()"
+
+	case "$board" in
+	lantiq,vgv952cjw33-e-ir )
+		# This is a global defined in nand.sh, sets another VID header offset than default.
+		# (now disabled, as it looks like eb904 can handle 512 byte subpages as reported by driver)
+		#echo "Set header offset"
+		#CU_UBI_VID_HEADER_OFFSET="2048"
+		;;
+	esac
+}
diff --git a/target/linux/lantiq/files-4.14/arch/mips/boot/dts/VGV952CJW33-E-IR.dts b/target/linux/lantiq/files-4.14/arch/mips/boot/dts/VGV952CJW33-E-IR.dts
new file mode 100644
index 0000000..a73ce20
--- /dev/null
+++ b/target/linux/lantiq/files-4.14/arch/mips/boot/dts/VGV952CJW33-E-IR.dts
@@ -0,0 +1,477 @@
+/dts-v1/;
+
+#include "vr9.dtsi"
+
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/mips/lantiq_rcu_gphy.h>
+
+/ {
+	model = "EasyBox 904 xDSL";
+	compatible = "lantiq,vgv952cjw33-e-ir", "lantiq,xway", "lantiq,vr9";
+
+	chosen {
+	    // No vpe, both cores used for linux:
+
+		//Rootfs is in partition 'ubi' if present, volume 'rootfs' (1st search prio). Or in mtd partition called 'rootfs' (2nd prio).
+		bootargs = "console=ttyLTQ0,115200";
+
+		// Obsolete:
+		// bootargs = "console=ttyLTQ0,115200 ubi.mtd=12,2048 panic=1 DTS-TEST-SEQNO=77 root=/dev/ubiblock0_0 rootdelay=7";
+
+
+	    // With vpe, one core dedicated to phone audio signal processing
+
+		// bootargs = "console=ttyLTQ0,115200 mem=116M phym=128M vpe1_load_addr=0x87e00000 vpe1_mem=2M maxvpes=1 maxtcs=1 nosmp";
+
+		// Bootargs to boot from sda1
+		// bootargs = "console=ttyLTQ0,115200 root=/dev/sda1 rootdelay=7 rootfstype=f2fs mem=116M phym=128M vpe1_load_addr=0x87e00000 vpe1_mem=2M maxvpes=1 maxtcs=1 nosmp";
+
+		// Obsolete:
+		// bootargs = "console=ttyLTQ0,115200 ubi.mtd=12,2048 panic=1 DTS-TEST-SEQNO=77  root=/dev/ubiblock0_0 rootdelay=7 mem=116M phym=128M vpe1_load_addr=0x87e00000 vpe1_mem=2M maxvpes=1 maxtcs=1 nosmp";
+		// Bootargs to boot from mtd12 ubifs
+		// bootargs = "console=ttyLTQ0,115200 ubi.mtd=12,2048 panic=1 DTS-TEST-SEQNO=77  root=/dev/ubiblock0_0 rootdelay=7 mem=116M phym=128M vpe1_load_addr=0x87e00000 vpe1_mem=2M maxvpes=1 maxtcs=1 nosmp";
+		// bootargs = "console=ttyLTQ0,115200 ubi.mtd=12,2048 panic=1 DTS-TEST-SEQNO=77 root=/dev/ubiblock0_0 rootdelay=7 mem=116M phym=128M vpe1_load_addr=0x87e00000 vpe1_mem=2M maxvpes=1 maxtcs=1 nosmp";
+		// bootargs = "console=ttyLTQ0,115200 mem=116M phym=128M vpe1_load_addr=0x87e00000 vpe1_mem=2M maxvpes=1 maxtcs=1 nosmp";
+		// Bootargs to boot from sda1
+		// bootargs = "console=ttyLTQ0,115200 panic=1 DTS-TEST-SEQNO=77 root=/dev/sda1 rootdelay=7 rootfstype=f2fs mem=116M phym=128M vpe1_load_addr=0x87e00000 vpe1_mem=2M maxvpes=1 maxtcs=1 nosmp";
+	};
+
+	memory@0 {
+		reg = <0x0 0x8000000>;
+	};
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+		rfkill {
+			label = "wps";
+			gpios = <&gpio 3 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_WPS_BUTTON>;
+		};
+		reset {
+			label = "reset";
+			gpios = <&gpio 40 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_RESTART>;
+		};
+	};
+
+	usb_vbus: regulator-usb-vbus {
+		compatible = "regulator-fixed";
+
+		regulator-name = "USB_VBUS";
+
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpio = <&gpio 33 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		power_green: power {
+		label = "VGV952CJW33:red:power";
+		gpios = <&gpio 31 GPIO_ACTIVE_HIGH>;
+		default-state = "keep";
+		};
+	};
+
+	spi {
+		compatible = "spi-gpio";
+		address-cells = <1>;
+		size-cells = <0>;
+
+		gpio-sck = <&gpio 29 GPIO_ACTIVE_HIGH >;
+		gpio-mosi = <&gpio 30 GPIO_ACTIVE_HIGH >;
+		num-chipselects = <1>;
+		cs-gpios = <&gpio 39 GPIO_ACTIVE_HIGH >;
+
+		hc595: gpio_spi@0 {
+			compatible = "fairchild,74hc595";
+			reg = <0>;
+			registers-number = <1>;
+			spi-max-frequency = <1000000>;
+			spi-cpol = <0>;
+			spi-cpha = <0>;
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+	};
+
+	gpio_export {
+		compatible = "gpio-export";
+		#size-cells = <0>;
+
+		out_0 { /*Unknown*/
+			gpio-export,name = "hc595_0";
+			gpio-export,output = <1>;
+			gpios = <&hc595 0 GPIO_ACTIVE_HIGH>;
+		};
+		out_1 {/*Unknown*/
+			gpio-export,name = "hc595_1";
+			gpio-export,output = <1>;
+			gpios = <&hc595 1 GPIO_ACTIVE_HIGH>;
+		};
+
+		// out_2 is used to reset touch IC and owned by eb904_keypad
+
+		out_3 {/*Unknown*/
+			gpio-export,name = "hc595_3";
+			gpio-export,output = <1>;
+			gpios = <&hc595 3 GPIO_ACTIVE_HIGH>;
+		};
+		out_dsl_eth { /* Switches DSL line + 100MiB eth or 1GiB ethernet on DSL/WAN input. Relay 1.*/
+			gpio-export,name = "dsl_en";
+			gpio-export,output = <1>;
+			gpios = <&hc595 4 GPIO_ACTIVE_LOW>;
+		};
+		out_5 { /* Switches filter for DSL line On/Off. Relays 2 and 3 simultaneously.*/
+			gpio-export,name = "annexj";
+			gpio-export,output = <1>;
+			gpios = <&hc595 5 GPIO_ACTIVE_HIGH>;
+		};
+		out_6 { /* Switch DSL line betwean ISDN modem and Si3050. Relay 5.*/
+			gpio-export,name = "annexb";
+			gpio-export,output = <1>;
+			gpios = <&hc595 6 GPIO_ACTIVE_HIGH>;
+		};
+		out_7 { /* Switch phone outputs N and F betwean analog DSL line and XS1 output from Lantiq SLIC. Relay 4.*/
+			gpio-export,name = "annexa";
+			gpio-export,output = <1>;
+			gpios = <&hc595 7 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	i2c {
+		compatible = "i2c-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		gpios = <&gpio 19 GPIO_ACTIVE_HIGH /* sda */
+			&gpio 14 GPIO_ACTIVE_HIGH /* scl */
+		>;
+		//i2c-gpio,sda-open-drain;
+		//i2c-gpio,scl-open-drain;
+		i2c-gpio,delay-us = <5>;
+		/* Add touch panel Support */
+		tp: eb904tp@0x14 {
+			compatible = "lantiq,eb904_keypad";
+			reg = <0x14>;
+			interrupt-parent = <&icu0>;
+			interrupts = <135>;
+			eb904,interrupt-gpio = <&gpio  0 GPIO_ACTIVE_HIGH /* EXIN */>;
+			eb904,ctrl-rst-gpio = <&hc595 2 GPIO_ACTIVE_LOW /* rst */>;
+			eb904,alphas = /bits/ 8
+				 <0x07 /* left */
+				  0x0a /* down */
+				  0x0a /* right */
+				  0x0a /* ok */
+				  0x07 /* up */
+			>;
+			keypad,num-rows = <3>;
+			keypad,num-columns = <3>;
+			linux,keymap = <
+				    MATRIX_KEY(0x0, 0x1, KEY_UP)         /* ROW0, COL1 */
+				    MATRIX_KEY(0x1, 0x0, KEY_LEFT)       /* ROW1, COL0 */
+				    MATRIX_KEY(0x1, 0x1, KEY_ENTER)      /* ROW1, COL1 */
+				    MATRIX_KEY(0x1, 0x2, KEY_RIGHT)      /* ROW1, COL2 */
+				    MATRIX_KEY(0x2, 0x1, KEY_DOWN)       /* ROW2, COL1 */
+				    >;
+		};
+	};
+
+	mdio: mdio {
+		compatible = "lantiq,xrx200-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		phy0: ethernet-phy@0 {
+			reg = <0x0>;
+			compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
+		};
+		phy1: ethernet-phy@1 {
+			reg = <0x1>;
+			compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
+		};
+		/*
+		phy5: ethernet-phy@5 {
+			reg = <0x5>;
+		};
+		*/
+		phy11: ethernet-phy@11 {
+			reg = <0x11>;
+			compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
+		};
+		phy12: ethernet-phy@12 {
+			reg = <0x12>;
+			compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
+		};
+		phy13: ethernet-phy@13 {
+			reg = <0x13>;
+			compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
+		};
+		phy14: ethernet-phy@14 {
+			reg = <0x14>;
+			compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
+		};
+	};
+
+	rtl8367b {
+		compatible = "realtek,rtl8367b";
+		//gpio-sda = <&gpio0 1 0>;
+		//gpio-sck = <&gpio0 2 0>;
+		//cpu_port = <7>;
+		//realtek,extif0 = <1 0 1 1 1 1 1 1 2>; // default found on other profiles
+		realtek,extif1   = <1 0 1 1 0 0 1 1 2>; // based on vendor uboot-config
+		mii-bus = <&mdio>;
+	};
+};
+
+&vmmc {
+	status = "okay";
+	gpios = <&gpio 37 GPIO_ACTIVE_HIGH>; //reset_slic!
+};
+
+&localbus {
+    //	#address-cells = <2>;					// Just for info. From vr9.dtsi
+    //	#size-cells = <1>;
+    //	ranges = <0 0 0x0       0x3ffffff			// addrsel0	0x3ffffff and 0x4000010 in vr9.dtsi seem to be wrong, because these are size
+    //    	  1 0 0x4000000 0x4000010>;			// addrsel1	parameters. Not really a problem; the drivers we have use their own hardcoded values
+
+	ranges = <0 0 0x0       0x2000000			// addrsel0	Was set up this way by arcadian eb904 U-Boot for nand. Not used by eb904 linux
+		  1 0 0x2000000 0x1000000			// addrsel1	Size 0x1000000 hardcoded in xway_nand.c. Excessive, as first 0x80 is used only
+		  2 0 0x3000000 0x0000800>;			// addrsel2	Size 0x800 hardcoded in display driver. This is the min size supported by ebu
+
+	nand@1 {						// @1 because using ebu BUSCON1/ADDSEL1
+		compatible = "lantiq,nand-xway";
+		reg = <1 0x0 0x80>;				// Only adresses 0x0..0x7F needed (but driver ignores size 0x80 and tells ebu to map 0x1000000)
+
+	    //	bank-width = <2>;				// Not used by any driver code
+		#address-cells = <1>;
+		#size-cells = <1>;
+		lantiq,cs = <1>;				// Seems to be needed (EASY80920NAND.dts)
+
+		nand-on-flash-bbt;
+		customized-samsung-K9F4G08U0x;
+
+		partitions {
+		compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "uboot";
+				reg = <0x0 0x40000>;
+			};
+
+			partition@40000 {
+				label = "rootfs1";		// Called "rootfs" in original u-boot env.
+				reg = <0x40000 0x3C00000>;	// Auto mounted as rootfs if no UBI volume named "rootfs" exists
+			};
+
+			partition@3C40000 {
+				label = "kernel";		// Called "kernel" in original u-boot env.
+				reg = <0x3C40000 0x500000>;
+			};
+
+			partition@4140000 {
+				label = "tmp1";
+				reg = <0x4140000 0x100000>;
+			};
+
+			partition@4240000 {
+				label = "tmp2";
+				reg = <0x4240000 0x200000>;
+			};
+
+			partition@4440000 {
+				label = "sysconfig";
+				reg = <0x4440000 0x100000>;
+			};
+
+			partition@4540000 {
+				label = "ubootconfig";
+				reg = <0x4540000 0x100000>;
+			};
+
+			partition@4640000 {
+				label = "fwdiag";
+				reg = <0x4640000 0xC0000>;
+			};
+
+			partition@4700000 {
+				label = "lcdimage";
+				reg = <0x4700000 0x300000>;
+			};
+
+			partition@4A00000 {
+				label = "mfgconfig";
+				reg = <0x4A00000 0x100000>;
+			};
+
+			partition@4B00000 {
+				label = "sipdata";
+				reg = <0x4B00000 0x100000>;
+			};
+
+			partition@4C00000 {
+				label = "voice";
+				reg = <0x4C00000 0x4000000>;
+			};
+
+			partition@8C00000 {			// Called "misc" in original u-boot env.
+				label = "ubi";			// Rename to "ubi" for auto ubi attachment and usage of rootfs, rootfs_data, kernel volumes
+				reg = <0x8C00000 0x13200000>;	// Rename to "firmware" for special squashfs-rootfs/jffs2-rootfs_data treatment
+			};
+
+			partition@1BE00000 {
+				label = "rootfs2";
+				reg = <0x1BE00000 0x3c00000>;
+			};
+
+			partition@1FA00000 {
+				label = "kernel2";
+				reg = <0x1FA00000 0x500000>;
+			};
+
+			partition@1FF00000 {
+				label = "mystery";		// Missing in original u-boot environment, seems to be empty (erased)
+				reg = <0x1FF00000 0x100000>;
+			};
+		};
+	};
+
+	display@2 {						// @2 because using ebu BUSCON2/ADDSEL2. Name not 'easybox904-display',
+		compatible = "ilitek,ili9341_eb904";		// see 'Node Names' at https://elinux.org/Device_Tree_Usage
+		reg = <2 0x0 0x4>;				// Size 0x4 contains 2 byte data and 2 byte command registers
+		status = "okay";
+		rotate = <270>;
+		fps = <30>;
+		bgr;
+		buswidth = <8>;
+		reset-gpios = <&gpio 6 GPIO_ACTIVE_HIGH>;
+		led-gpios = <&gpio 28 GPIO_ACTIVE_HIGH>;
+		debug = <1>;
+	};
+};
+
+/*
+*  Following is the very experimental part which is broken and requires much more elaboration
+*/
+
+// From FRITZ3370.dts
+&gpio {
+	pinctrl-names = "default";
+	pinctrl-0 = <&state_default>;
+
+	state_default: pinmux {
+		mdio {
+			lantiq,groups = "mdio";
+			lantiq,function = "mdio";
+		};
+
+		phy-rst {	// I have no idea wether this makes sense
+			lantiq,pins = "io37", "io44";			// FRITZ3370.dts
+		  //	lantiq,pins = "io42";				// TDW8970.dts
+			lantiq,pull = <0>;
+			lantiq,open-drain = <0>;
+			lantiq,output = <1>;
+						};
+
+		pcie-rst {
+			lantiq,pins = "io38";				// FRITZ3370.dts, TDW8970.dts, EASY80920.dtsi, P2812HNUFX.dtsi
+		   //	lantiq,pins = "io21";				// ARV7519RW22.dts
+			lantiq,pull = <0>;
+			lantiq,output = <1>;
+		};
+
+		exin1 {
+			lantiq,groups = "exin1";
+			lantiq,function = "exin";
+		};
+
+		conf_tp {
+			lantiq,pins = "io1"; /* exin1 */
+			lantiq,open-drain;
+			lantiq,pull = <0>;
+		};
+		conf_spi {
+			lantiq,pins = "io29", "io30", "io39"; /* gpiois for spi */
+			lantiq,pull = <2>; /*Pull Up*/
+		};
+	};
+};
+
+&usb_phy0 {
+	status = "okay";
+};
+
+&usb_phy1 {
+	status = "okay";
+};
+
+&usb0 {
+	status = "okay";
+	vbus-supply = <&usb_vbus>;
+};
+
+&usb1 {
+	status = "okay";
+	vbus-supply = <&usb_vbus>;
+};
+
+&eth0 {
+	lan: interface@0 {
+		compatible = "lantiq,xrx200-pdi";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0>;
+		mac-address = [ 00 11 22 33 44 55 ];
+		lantiq,switch;
+		ethernet@2 {
+			compatible = "lantiq,xrx200-pdi-port";
+			reg = <2>;
+			phy-mode = "gmii";
+			// phy-handle = <&phy11>;
+			fixed-link {
+				speed = <1000>;
+				full-duplex;
+			};
+		};
+		/* wan port */
+		ethernet@4 {
+			compatible = "lantiq,xrx200-pdi-port";
+			reg = <4>;
+			phy-mode = "gmii";
+			phy-handle = <&phy13>;
+		};
+		/* rt3883 soc */
+		/*
+		ethernet@5 {
+			compatible = "lantiq,xrx200-pdi-port";
+			reg = <5>;
+			phy-mode = "rgmii";
+			phy-handle = <&phy5>;
+		};
+		*/
+	};
+};
+
+&pci0 {
+	status = "disabled";
+	//gpio-reset = <&gpio 21 GPIO_ACTIVE_HIGH>;
+};
+
+&pcie0 {
+	pcie@0 {
+		reg = <0 0 0 0 0>;
+		#interrupt-cells = <1>;
+		#size-cells = <2>;
+		#address-cells = <3>;
+		device_type = "pci";
+	};
+};
+
+
+
diff --git a/target/linux/lantiq/image/Makefile b/target/linux/lantiq/image/Makefile
index b59acf4..eec0431 100644
--- a/target/linux/lantiq/image/Makefile
+++ b/target/linux/lantiq/image/Makefile
@@ -20,6 +20,21 @@ else
   UBIFS_OPTS := -m 2048 -e 126KiB -c 4096
 endif
 
+define Build/append-uImage-rootfs
+	mkimage -A mips -O linux -C none -T filesystem  \
+		-n 'OpenWRT RootFS' \
+		-d $(IMAGE_ROOTFS) $@.mkimage
+	cat $@.mkimage >> $@
+endef
+
+define Build/append-uImage-dummyrootfs
+	echo -n "dummy" > $@.dummyrootfs
+	mkimage -A mips -O linux -C none -T filesystem  \
+		-n 'OpenWRT dummy RootFS' \
+		-d $@.dummyrootfs $@.mkimage
+	cat $@.mkimage >> $@
+endef
+
 define Build/append-avm-fakeroot
 	cat ./eva.dummy.squashfs >> $@
 endef
@@ -489,7 +504,7 @@ define Device/avm_fritz7312
   $(Device/AVM)
   DEVICE_DTS := FRITZ7312
   IMAGE_SIZE := 15744k
-  DEVICE_TITLE := AVM FRITZ!Box 7312
+  DEVICE_TITLE := 1&1 WLAN-MODEM - FRITZ7312
   DEVICE_PACKAGES := kmod-ath9k kmod-owl-loader wpad-mini \
 	kmod-ltq-adsl-ar9-mei kmod-ltq-adsl-ar9 \
 	kmod-ltq-adsl-ar9-fw-b kmod-ltq-atm-ar9 \
@@ -502,7 +517,7 @@ define Device/avm_fritz7320
   $(Device/AVM)
   DEVICE_DTS := FRITZ7320
   IMAGE_SIZE := 15744k
-  DEVICE_TITLE := AVM FRITZ!Box 7320
+  DEVICE_TITLE := 1&1 HomeServer - FRITZ7320
   DEVICE_PACKAGES := kmod-ath9k kmod-owl-loader wpad-basic \
 	kmod-ltq-adsl-ar9-mei kmod-ltq-adsl-ar9 \
 	kmod-ltq-adsl-ar9-fw-b kmod-ltq-atm-ar9 \
@@ -594,6 +609,31 @@ define Device/bt_homehub-v5a
 endef
 TARGET_DEVICES += bt_homehub-v5a
 
+define Device/lantiq_vgv952cjw33-e-ir
+  $(Device/NAND)
+  BOARD_NAME := VGV952CJW33-E-IR
+  DEVICE_DTS := VGV952CJW33-E-IR
+  DEVICE_TITLE := Easybox 904 / Arcadyan VGV952CJW33-E-IR
+  DEVICE_PACKAGES := kmod-usb-dwc2 kmod-ltq-tapi kmod-ltq-vmmc wpad-basic
+  SUPPORTED_DEVICES += VGV952CJW33-E-IR
+# If the rootfs/squashfs should be placed in mtd1: flashing can be done with the reset-button-during-
+# power-on recovery procedure using fullimage.img, or with sysupgrade procedure using sysupgrade.bin.
+# In the .dts file, partition mtd1 MUST be named 'rootfs', and partition mtd12 MUST NOT be named 'ubi'.
+ #IMAGES := sysupgrade.bin fullimage.img
+ #IMAGE/fullimage.img := append-uImage-rootfs | pad-offset 16 0 | append-kernel
+# If the rootfs/squashfs should be placed in an UBI volume in mtd12:
+# flashing can be done with the sysupgrade procedure.
+# In the .dts file, partition mtd1 MUST NOT be named 'rootfs', and partition mtd12 MUST be named 'ubi'.
+  IMAGES := sysupgrade.bin
+# Generate an initramfs file containing an additional dummy squashfs image. This way the original vendor U-Boot
+# can flash it to the mtd2 kernel partition via the reset-button-press-during-power-on recovery procedure
+# if 1) size is max 0x500000 bytes and 2) the initramfs file is manually renamed to fullimage.img.
+# BTW: the uboot-lantiq-easybox904xdsl U-Boot allows larger sizes and starts the initramfs directly without flashing.
+  KERNEL_INITRAMFS := kernel-bin | append-dtb | lzma | uImage lzma | pad-offset 16 0 | append-uImage-dummyrootfs
+ #KERNEL_INITRAMFS := kernel-bin | append-dtb | lzma | uImage lzma | pad-offset 16 0 | append-uImage-dummyrootfs | check-size 0x500000
+endef
+TARGET_DEVICES += lantiq_vgv952cjw33-e-ir
+
 define Device/netgear_dm200
   DEVICE_DTS := DM200
   IMAGES := sysupgrade.bin factory.img
@@ -631,7 +671,7 @@ define Device/avm_fritz3370
   $(Device/AVM)
   $(Device/NAND)
   DEVICE_DTS := FRITZ3370
-  DEVICE_TITLE := AVM FRITZ!Box 3370 Rev. 2
+  DEVICE_TITLE := AVM Fritz!Box WLan 3370 Rev. 2
   KERNEL_SIZE := 4096k
   UBINIZE_OPTS := -E 5
   IMAGES += eva-kernel.bin eva-filesystem.bin
@@ -643,14 +683,14 @@ endef
 define Device/avm_fritz3370-rev2-hynix
   $(Device/avm_fritz3370)
   DEVICE_DTS := FRITZ3370-REV2-HYNIX
-  DEVICE_TITLE := AVM FRITZ!Box 3370 Rev. 2 (Hynix NAND)
+  DEVICE_TITLE := AVM Fritz!Box WLan 3370 Rev. 2 (Hynix NAND)
 endef
 TARGET_DEVICES += avm_fritz3370-rev2-hynix
 
 define Device/avm_fritz3370-rev2-micron
   $(Device/avm_fritz3370)
   DEVICE_DTS := FRITZ3370-REV2-MICRON
-  DEVICE_TITLE := AVM FRITZ!Box 3370 Rev. 2 (Micron NAND)
+  DEVICE_TITLE := AVM Fritz!Box WLan 3370 Rev. 2 (Micron NAND)
 endef
 TARGET_DEVICES += avm_fritz3370-rev2-micron
 
@@ -658,7 +698,7 @@ define Device/avm_fritz7360sl
   $(Device/AVM)
   IMAGE_SIZE := 15744k
   DEVICE_DTS := FRITZ7360SL
-  DEVICE_TITLE := AVM FRITZ!Box 7360 SL
+  DEVICE_TITLE := 1&1 HomeServer - FRITZ7360SL
   DEVICE_PACKAGES := kmod-ath9k kmod-owl-loader wpad-basic kmod-usb-dwc2
   SUPPORTED_DEVICES += FRITZ7360SL
 endef
diff --git a/target/linux/lantiq/patches-4.14/4027-NET-MIPS-lantiq-support-fixed-link.patch b/target/linux/lantiq/patches-4.14/4027-NET-MIPS-lantiq-support-fixed-link.patch
new file mode 100644
index 0000000..fe12861
--- /dev/null
+++ b/target/linux/lantiq/patches-4.14/4027-NET-MIPS-lantiq-support-fixed-link.patch
@@ -0,0 +1,84 @@
+--- a/drivers/net/ethernet/lantiq_xrx200.c
++++ b/drivers/net/ethernet/lantiq_xrx200.c
+@@ -1319,31 +1319,43 @@ static int xrx200_mdio_probe(struct net_
+ 	struct phy_device *phydev = NULL;
+ 	unsigned val;
+ 
+-	phydev = mdiobus_get_phy(priv->hw->mii_bus, port->phy_addr);
++	if (of_phy_is_fixed_link(port->phy_node)) {
++		netdev_info(dev, "Connect as fixed link.\n");
++		phydev = of_phy_connect(dev, port->phy_node, &xrx200_mdio_link, 0,
++				port->phy_if);
+ 
+-	if (!phydev) {
+-		netdev_err(dev, "no PHY found\n");
+-		return -ENODEV;
+-	}
++		if (IS_ERR(phydev)) {
++			netdev_err(dev, "Could not attach to PHY\n");
++			return PTR_ERR(phydev);
++		}
++	}else{
++		netdev_info(dev, "Connect as common phy link.\n");
++		phydev = mdiobus_get_phy(priv->hw->mii_bus, port->phy_addr);
++		if (!phydev) {
++			netdev_err(dev, "no PHY found\n");
++			return -ENODEV;
++		}
+ 
+-	phydev = phy_connect(dev, phydev_name(phydev), &xrx200_mdio_link,
+-				port->phy_if);
++		phydev = phy_connect(dev, phydev_name(phydev), &xrx200_mdio_link,
++					port->phy_if);
+ 
+-	if (IS_ERR(phydev)) {
+-		netdev_err(dev, "Could not attach to PHY\n");
+-		return PTR_ERR(phydev);
++		if (IS_ERR(phydev)) {
++			netdev_err(dev, "Could not attach to PHY\n");
++			return PTR_ERR(phydev);
++		}
++
++		phydev->supported &= (SUPPORTED_10baseT_Half
++				| SUPPORTED_10baseT_Full
++				| SUPPORTED_100baseT_Half
++				| SUPPORTED_100baseT_Full
++				| SUPPORTED_1000baseT_Half
++				| SUPPORTED_1000baseT_Full
++				| SUPPORTED_Autoneg
++				| SUPPORTED_MII
++				| SUPPORTED_TP);
++		phydev->advertising = phydev->supported;
+ 	}
+ 
+-	phydev->supported &= (SUPPORTED_10baseT_Half
+-			| SUPPORTED_10baseT_Full
+-			| SUPPORTED_100baseT_Half
+-			| SUPPORTED_100baseT_Full
+-			| SUPPORTED_1000baseT_Half
+-			| SUPPORTED_1000baseT_Full
+-			| SUPPORTED_Autoneg
+-			| SUPPORTED_MII
+-			| SUPPORTED_TP);
+-	phydev->advertising = phydev->supported;
+ 	port->phydev = phydev;
+ 	phydev->no_auto_carrier_off = true;
+ 
+@@ -1630,6 +1642,17 @@ static void xrx200_of_port(struct xrx200
+ 
+ 	memset(p, 0, sizeof(struct xrx200_port));
+ 	p->phy_node = of_parse_phandle(port, "phy-handle", 0);
++
++	if (!p->phy_node && of_phy_is_fixed_link(port)) {
++		pr_info("Static link. Port <%d>!\n", p->num);
++		if (of_phy_register_fixed_link(port)<0){
++			pr_info("invalid fixed-link\n");
++		}else{
++			pr_info("Registered fixed-link\n");
++		}
++		p->phy_node = of_node_get(port);
++	}
++
+ 	addr = of_get_property(p->phy_node, "reg", NULL);
+ 	if (!addr)
+ 		return;
diff --git a/target/linux/lantiq/patches-4.14/4028-NET-MIPS-lantiq-add-FID-setting.patch b/target/linux/lantiq/patches-4.14/4028-NET-MIPS-lantiq-add-FID-setting.patch
new file mode 100644
index 0000000..37c72ac
--- /dev/null
+++ b/target/linux/lantiq/patches-4.14/4028-NET-MIPS-lantiq-add-FID-setting.patch
@@ -0,0 +1,86 @@
+diff --git a/drivers/net/ethernet/lantiq_xrx200.c b/drivers/net/ethernet/lantiq_xrx200.c
+index a19a127..8b8295b 100644
+--- a/drivers/net/ethernet/lantiq_xrx200.c
++++ b/drivers/net/ethernet/lantiq_xrx200.c
+@@ -568,6 +568,35 @@ static int xrx200sw_get_vlan_vid(struct switch_dev *dev, const struct switch_att
+ 	return 0;
+ }
+ 
++static int xrx200sw_set_vlan_fid(struct switch_dev *dev, const struct switch_attr *attr,
++				 struct switch_val *val)
++{
++	int i;
++	struct xrx200_pce_table_entry tev;
++
++	tev.table = XRX200_PCE_ACTVLAN_IDX;
++
++	tev.index = val->port_vlan;
++	xrx200_pce_table_entry_read(&tev);
++	tev.val[0] = val->value.i;
++	xrx200_pce_table_entry_write(&tev);
++
++	return 0;
++}
++
++static int xrx200sw_get_vlan_fid(struct switch_dev *dev, const struct switch_attr *attr,
++				 struct switch_val *val)
++{
++	struct xrx200_pce_table_entry te;
++
++	te.table = XRX200_PCE_ACTVLAN_IDX;
++	te.index = val->port_vlan;
++	xrx200_pce_table_entry_read(&te);
++	val->value.i = te.val[0];
++
++	return 0;
++}
++
+ static int xrx200sw_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
+ {
+ 	struct xrx200_hw *hw = container_of(dev, struct xrx200_hw, swdev);
+@@ -708,6 +737,30 @@ static int xrx200sw_get_port_pvid(struct switch_dev *dev, int port, int *val)
+ 	return 0;
+ }
+ 
++static int xrx200sw_set_port_pvid(struct switch_dev *dev, int port, int val)
++{
++	int i;
++	struct xrx200_pce_table_entry tev;
++
++	if (port >= XRX200_MAX_PORT)
++		return -EINVAL;
++
++	tev.table = XRX200_PCE_ACTVLAN_IDX;
++
++	for (i = 0; i < XRX200_MAX_VLAN; i++)
++	{
++		tev.index = i;
++		xrx200_pce_table_entry_read(&tev);
++		if (tev.key[0] == val)
++		{
++			xrx200sw_write_x(i, XRX200_PCE_DEFPVID_PVID, port);
++			return 0;
++		}
++	}
++
++	return -EINVAL;
++}
++
+ static int xrx200sw_get_port_link(struct switch_dev *dev,
+ 				  int port,
+ 				  struct switch_port_link *link)
+@@ -804,6 +857,14 @@ static struct switch_attr xrx200sw_vlan[] = {
+ 	},
+ 	{
+ 		.type = SWITCH_TYPE_INT,
++		.name = "fid",
++		.description = "Filtering Identifier (0-63)",
++		.set = xrx200sw_set_vlan_fid,
++		.get = xrx200sw_get_vlan_fid,
++		.max = 63,
++	},
++	{
++		.type = SWITCH_TYPE_INT,
+ 		.name = "enable",
+ 		.description = "Enable VLAN",
+ 		.set = xrx200sw_set_vlan_enable,
diff --git a/target/linux/lantiq/patches-4.14/4050-MIPS-lantiq-EBU-set_buscon_params.patch b/target/linux/lantiq/patches-4.14/4050-MIPS-lantiq-EBU-set_buscon_params.patch
new file mode 100644
index 0000000..b24fbbc
--- /dev/null
+++ b/target/linux/lantiq/patches-4.14/4050-MIPS-lantiq-EBU-set_buscon_params.patch
@@ -0,0 +1,32 @@
+--- a/arch/mips/include/asm/mach-lantiq/xway/lantiq_soc.h
++++ b/arch/mips/include/asm/mach-lantiq/xway/lantiq_soc.h
+@@ -87,6 +87,8 @@ extern __iomem void *ltq_cgu_membase;
+ #define LTQ_EBU_PCC_ISTAT	0x00A0
+ #define LTQ_EBU_BUSCON1		0x0064
+ #define LTQ_EBU_ADDRSEL1	0x0024
++#define LTQ_EBU_BUSCON2		0x0068
++#define LTQ_EBU_ADDRSEL2	0x0028
+ #define EBU_WRDIS		0x80000000
+ 
+ /* WDT */
+--- a/arch/mips/lantiq/xway/sysctrl.c
++++ b/arch/mips/lantiq/xway/sysctrl.c
+@@ -147,7 +147,9 @@
+ 
+ static void __iomem *pmu_membase;
+ void __iomem *ltq_cgu_membase;
++
+ void __iomem *ltq_ebu_membase;
++EXPORT_SYMBOL(ltq_ebu_membase);
+ 
+ static u32 ifccr = CGU_IFCCR;
+ static u32 pcicr = CGU_PCICR;
+@@ -474,7 +476,7 @@
+ 	if (!pmu_membase || !ltq_cgu_membase || !ltq_ebu_membase)
+ 		panic("Failed to remap core resources");
+ 
+-	/* make sure to unprotect the memory region where flash is located */
++	/* make sure to unprotect the memory region where NOR flash is located */
+ 	ltq_ebu_w32(ltq_ebu_r32(LTQ_EBU_BUSCON0) & ~EBU_WRDIS, LTQ_EBU_BUSCON0);
+ 
+ 	/* add our generic xway clocks */
diff --git a/target/linux/lantiq/patches-4.14/4052-NAND-add-easybox904-bbt-byDTS.patch b/target/linux/lantiq/patches-4.14/4052-NAND-add-easybox904-bbt-byDTS.patch
new file mode 100644
index 0000000..b83d6c1
--- /dev/null
+++ b/target/linux/lantiq/patches-4.14/4052-NAND-add-easybox904-bbt-byDTS.patch
@@ -0,0 +1,131 @@
+diff -aurN a/drivers/mtd/nand/nand_bbt.c b/drivers/mtd/nand/nand_bbt.c
+--- a/drivers/mtd/nand/nand_bbt.c	2019-02-26 10:04:39.551525839 +0000
++++ b/drivers/mtd/nand/nand_bbt.c	2019-02-26 10:04:39.697524014 +0000
+@@ -76,6 +76,32 @@
+ #define BBT_ENTRY_MASK		0x03
+ #define BBT_ENTRY_SHIFT		2
+ 
++#define CUSTOMIZED_BBT 1
++#if CUSTOMIZED_BBT
++  #define	BAD_BLK_OOB_MARK_START	4
++  #define	BAD_BLK_OOB_MARK_END	5
++  #define	BAD_BLK_OOB_MARK_PATT	0xFF
++
++
++#include <linux/mtd/rawnand.h>
++#include <linux/of.h>
++
++static bool of_get_customized_bbt_from_mtd(struct mtd_info *mtd)
++{
++	struct nand_chip *chip = mtd_to_nand(mtd);
++	struct device_node *dn = nand_get_flash_node(chip);
++	return of_property_read_bool(dn, "customized-samsung-K9F4G08U0x");
++}
++
++static bool of_get_customized_bbt_from_chip(struct nand_chip *chip)
++{
++	struct device_node *dn = nand_get_flash_node(chip);
++	return of_property_read_bool(dn, "customized-samsung-K9F4G08U0x");
++}
++
++#endif
++
++
+ static int nand_update_bbt(struct mtd_info *mtd, loff_t offs);
+ 
+ static inline uint8_t bbt_get_entry(struct nand_chip *chip, int block)
+@@ -109,8 +135,15 @@
+  * Check for a pattern at the given place. Used to search bad block tables and
+  * good / bad block identifiers.
+  */
++#if CUSTOMIZED_BBT
++static int check_pattern(struct mtd_info *mtd, uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
++{
++	int i;
++	uint8_t *p = buf;
++#else
+ static int check_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
+ {
++#endif
+ 	if (td->options & NAND_BBT_NO_OOB)
+ 		return check_pattern_no_oob(buf, td);
+ 
+@@ -118,6 +151,15 @@
+ 	if (memcmp(buf + paglen + td->offs, td->pattern, td->len))
+ 		return -1;
+ 
++#if CUSTOMIZED_BBT /*ctc*/
++	if (of_get_customized_bbt_from_mtd(mtd)) {
++		for (i = BAD_BLK_OOB_MARK_START, p=buf+paglen; i <= BAD_BLK_OOB_MARK_END; i++) {
++			if (p[i] != BAD_BLK_OOB_MARK_PATT)
++				return -1;
++		}
++	}
++#endif
++
+ 	return 0;
+ }
+ 
+@@ -561,7 +603,11 @@
+ 
+ 			/* Read first page */
+ 			scan_read(mtd, buf, offs, mtd->writesize, td);
++#if CUSTOMIZED_BBT
++			if (!check_pattern(mtd, buf, scanlen, mtd->writesize, td)) {
++#else
+ 			if (!check_pattern(buf, scanlen, mtd->writesize, td)) {
++#endif
+ 				td->pages[i] = actblock << blocktopage;
+ 				if (td->options & NAND_BBT_VERSION) {
+ 					offs = bbt_get_ver_offs(mtd, td);
+@@ -1277,8 +1323,13 @@
+ static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+ 
+ /* Generic flash bbt descriptors */
++//#if CUSTOMIZED_BBT /*ctc*/
++//static uint8_t bbt_pattern[] = {'A', 'R', 'C', 'A' };
++//static uint8_t mirror_pattern[] = {'a', 'c', 'r', 'a' };
++//#else
+ static uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };
+ static uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };
++//#endif
+ 
+ static struct nand_bbt_descr bbt_main_descr = {
+ 	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+@@ -1340,7 +1391,16 @@
+ 	bd = kzalloc(sizeof(*bd), GFP_KERNEL);
+ 	if (!bd)
+ 		return -ENOMEM;
++
++#if CUSTOMIZED_BBT /*ctc*/
++	if (of_get_customized_bbt_from_chip(this)) {
++		bd->options = 0 & BADBLOCK_SCAN_MASK;
++	} else {
++		bd->options = this->bbt_options & BADBLOCK_SCAN_MASK;
++	}
++#else
+ 	bd->options = this->bbt_options & BADBLOCK_SCAN_MASK;
++#endif
+ 	bd->offs = this->badblockpos;
+ 	bd->len = (this->options & NAND_BUSWIDTH_16) ? 2 : 1;
+ 	bd->pattern = scan_ff_pattern;
+@@ -1360,6 +1420,19 @@
+ {
+ 	struct nand_chip *this = mtd_to_nand(mtd);
+ 	int ret;
++/* change the generic bad / good block scan pattern if of_get_customized_bbt_from_chip(this) true */
++#if CUSTOMIZED_BBT
++	if(of_get_customized_bbt_from_chip(this)) {
++		bbt_pattern[0] = 'A';
++		bbt_pattern[1] = 'R';
++		bbt_pattern[2] = 'C';
++		bbt_pattern[3] = 'A';
++		mirror_pattern[0] = 'a';
++		mirror_pattern[1] = 'c';
++		mirror_pattern[2] = 'r';
++		mirror_pattern[3] = 'a';
++	}
++#endif
+ 
+ 	/* Is a flash based bad block table requested? */
+ 	if (this->bbt_options & NAND_BBT_USE_FLASH) {
diff --git a/target/linux/lantiq/patches-4.14/4053-NET-reactivate-ndo_do_ioctl-fallback.patch b/target/linux/lantiq/patches-4.14/4053-NET-reactivate-ndo_do_ioctl-fallback.patch
new file mode 100644
index 0000000..cdb6d4e
--- /dev/null
+++ b/target/linux/lantiq/patches-4.14/4053-NET-reactivate-ndo_do_ioctl-fallback.patch
@@ -0,0 +1,27 @@
+From c9701bab45cf3fa244033fcf5e4341a1de627807 Mon Sep 17 00:00:00 2001
+From: Quallenauge <Hamsi2k@freenet.de>
+Date: Mon, 21 May 2018 23:55:01 -0100
+Subject: [PATCH] VGV952CJW33-E-IR: Revert "wireless: wext: remove ndo_do_ioctl
+ fallback" This reverts commit 8bfb3676606454ffec836f56c5dc3e69dfc0956a.
+
+The ralink inic driver currently uses this for controlling the network
+adapters. In future versions the driver has to be modernized to comply
+with future kernel drivers.
+---
+ net/wireless/wext-core.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+Index: linux-4.14.41/net/wireless/wext-core.c
+===================================================================
+--- linux-4.14.41.orig/net/wireless/wext-core.c
++++ linux-4.14.41/net/wireless/wext-core.c
+@@ -956,6 +956,9 @@ static int wireless_process_ioctl(struct
+ 		else if (private)
+ 			return private(dev, iwr, cmd, info, handler);
+ 	}
++	/* Old driver API : call driver ioctl handler */
++	if (dev->netdev_ops->ndo_do_ioctl)
++		return dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq *)iwr, cmd);
+ 	return -EOPNOTSUPP;
+ }
+ 
diff --git a/target/linux/lantiq/patches-4.14/4055-NET-rtl8367b-wait-for-mdio-bus.patch b/target/linux/lantiq/patches-4.14/4055-NET-rtl8367b-wait-for-mdio-bus.patch
new file mode 100644
index 0000000..7325c67
--- /dev/null
+++ b/target/linux/lantiq/patches-4.14/4055-NET-rtl8367b-wait-for-mdio-bus.patch
@@ -0,0 +1,54 @@
+From 5a5d5130a628583c4137110a3189fe2f3c5c265a Mon Sep 17 00:00:00 2001
+From: Quallenauge <Hamsi2k@freenet.de>
+Date: Wed, 27 Jun 2018 20:35:47 +0200
+Subject: [PATCH] rtl8367b: Defer init until mdio bus appears.
+
+---
+ drivers/net/phy/rtl8367b.c | 21 +++++++++++++++++++++
+ 1 file changed, 21 insertions(+)
+
+diff --git a/drivers/net/phy/rtl8367b.c b/drivers/net/phy/rtl8367b.c
+index e6ea6509..770bf0bc 100644
+--- a/drivers/net/phy/rtl8367b.c
++++ b/drivers/net/phy/rtl8367b.c
+@@ -17,9 +17,11 @@
+ #include <linux/delay.h>
+ #include <linux/skbuff.h>
+ #include <linux/rtl8367.h>
++#include <linux/of_mdio.h>
+ 
+ #include "rtl8366_smi.h"
+ 
++
+ #define RTL8367B_RESET_DELAY	1000	/* msecs*/
+ 
+ #define RTL8367B_PHY_ADDR_MAX	8
+@@ -1526,6 +1528,25 @@ static int  rtl8367b_probe(struct platform_device *pdev)
+ 	struct rtl8366_smi *smi;
+ 	int err;
+ 
++#ifdef CONFIG_OF
++    struct device_node *np = pdev->dev.of_node;
++	struct device_node *mdio_node;
++	struct mii_bus * ext_mbus;
++	mdio_node = of_parse_phandle(np, "mii-bus", 0);
++	if (!mdio_node) {
++		dev_err(&pdev->dev, "cannot find mdio node phandle");
++		goto try_gpio;
++	}
++
++	ext_mbus = of_mdio_find_bus(mdio_node);
++	if (!ext_mbus) {
++		dev_err(&pdev->dev,
++			"cannot find mdio bus from bus handle, try again later");
++		return -EPROBE_DEFER;
++	}
++
++try_gpio:
++#endif
+ 	smi = rtl8366_smi_probe(pdev);
+ 	if (!smi)
+ 		return -ENODEV;
+-- 
+2.18.0
+
diff --git a/target/linux/lantiq/patches-4.14/4056-MTD-nand_samsung_disable_subpage_writes_on_21nm_NAND.patch b/target/linux/lantiq/patches-4.14/4056-MTD-nand_samsung_disable_subpage_writes_on_21nm_NAND.patch
new file mode 100644
index 0000000..d3d42c9
--- /dev/null
+++ b/target/linux/lantiq/patches-4.14/4056-MTD-nand_samsung_disable_subpage_writes_on_21nm_NAND.patch
@@ -0,0 +1,55 @@
+From e81d56d247a8c93d24e03be378d1748f3e044e6b Mon Sep 17 00:00:00 2001
+From: Ladislav Michl <ladis@linux-mips.org>
+Date: Tue, 9 Jan 2018 14:19:11 +0100
+Subject: [PATCH] VGV952CJW33-E-IR: mtd: nand: samsung: Disable subpage writes on 21nm NAND.
+
+Some Samsung SLC NAND are manufactured using the 21nm process.
+They does not supports partial page programming, so disable subpage writes
+for it. Manufacturing process is stored in lowest two bits of 5th ID
+byte.
+
+This patch is derived and adapted from the upstream patch which
+handles a different samsung NAND flash devie (K9F1G08U0E) and is named
+mtd: nand: samsung: Disable subpage writes on E-die NAND
+and available since kernel release v4.16.
+---
+ drivers/mtd/nand/nand_samsung.c | 22 ++++++++++++++++++++++
+ 1 file changed, 22 insertions(+)
+
+Index: linux-4.14.78/drivers/mtd/nand/nand_samsung.c
+===================================================================
+--- linux-4.14.78.orig/drivers/mtd/nand/nand_samsung.c
++++ linux-4.14.78/drivers/mtd/nand/nand_samsung.c
+@@ -20,6 +20,9 @@
+ static void samsung_nand_decode_id(struct nand_chip *chip)
+ {
+ 	struct mtd_info *mtd = nand_to_mtd(chip);
++	u8 *d  = chip->id.data;
++	pr_debug("samsung_nand_decode_id: ID is len=%d, %02X %02X %02X %02X %02X %02X %02X %02X\n",
++		chip->id.len, d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7]);
+ 
+ 	/* New Samsung (6 byte ID): Samsung K9GAG08U0F (p.44) */
+ 	if (chip->id.len == 6 && !nand_is_slc(chip) &&
+@@ -91,6 +94,22 @@ static void samsung_nand_decode_id(struc
+ 		}
+ 	} else {
+ 		nand_decode_ext_id(chip);
++		if (nand_is_slc(chip)) {
++			switch (chip->id.data[1]) {
++				/*K9F4G08U0D / K9K8G08U0D / K9K8G08U1D / K9WAG08U1D */
++				case 0xDC:
++					if (chip->id.len > 4 &&
++					    (chip->id.data[4] & GENMASK(1, 0)) == 0x1) {
++						chip->options |= NAND_NO_SUBPAGE_WRITE;
++						pr_debug("samsung_nand_decode_id: id.data[1] is 0x%02X, disabling subpage writes\n", d[1]);
++					} else {
++						pr_debug("samsung_nand_decode_id: id.data[1] is 0x%02X, allowing subpage writes\n", d[1]);
++					}
++				break;
++				default:
++					break;
++			}
++		}
+ 	}
+ }
+ 
-- 
2.7.4

